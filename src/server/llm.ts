import { createOpenAI } from "@ai-sdk/openai";
import { generateObject, generateText } from "ai";
import z from "zod";
import { Ingredient, Recipe } from "../lib/types";
import { GlassTypeSchema, IngredientSchema } from "../lib/validation";

export function createGitHubModels() {
  const githubToken = process.env.GITHUB_TOKEN;
  if (!githubToken) {
    throw new Error("GitHub token not configured");
  }

  return createOpenAI({
    apiKey: githubToken,
    baseURL: "https://models.github.ai/inference",
  });
}

export async function generateRecipeTags({
  name,
  ingredients,
}: {
  name?: string;
  ingredients: Ingredient[];
}): Promise<string[]> {
  const githubModels = createGitHubModels();
  const systemPrompt = `You are an expert cocktail sommelier. Generate a list of relevant tags for a cocktail recipe based on its ingredients and name.
  Guidelines:
  - Focus on flavor profiles, ingredients, and cocktail types
  - Keep it concise, 3-5 tags maximum
  - Avoid generic tags like "cocktail" or "drink"
  - Use lowercase, no spaces, separate with commas
  - Do not include the name of the cocktail in the tags`;

  const userPrompt = `Generate tags for a cocktail recipe with these ingredients: ${ingredients
    .map((ing) => `${ing.amount} ${ing.unit} ${ing.name}`)
    .join(", ")}${name ? ` and name "${name}"` : ""}`;

  const result = await generateObject({
    model: githubModels(process.env.CHAT_MODEL || "openai/gpt-4.1-nano"),
    system: systemPrompt,
    prompt: userPrompt,
    schema: z.object({
      tags: z.array(z.string().min(1)),
    }),
  });

  if (!result && !result.object) {
    console.warn("No tags generated by LLM");
  }
  return result.object.tags;
}

export async function generateRecipeDescription({
  ingredients,
  name,
}: {
  ingredients: Ingredient[];
  name?: string;
}): Promise<string> {
  const githubModels = createGitHubModels();

  // Create ingredient list for prompt
  const ingredientsList = ingredients
    .map((ing) => `${ing.amount} ${ing.unit} ${ing.name}`)
    .join(", ");

  // Create system prompt for description generation
  const systemPrompt = `You are an expert cocktail sommelier and writer. Generate a simple description for a cocktail based on its ingredients. 

Guidelines:
- Focus on flavor profiles rather than exact measurements
- Highlight the most interesting or premium ingredients
- Keep it to 1-2 sentences maximum
- Do not be verbose. Be concise.
- Don't mention specific amounts or measurements
- Make it sound appealing and interesting
- DO NOT make it sound pretentious.
- Don't include the name of the cocktail in the description`;

  const userPrompt = `Create a description for a cocktail${
    name ? ` called "${name}"` : ""
  } with these ingredients: ${ingredientsList}`;

  const result = await generateText({
    model: githubModels(process.env.CHAT_MODEL || "openai/gpt-4.1-nano"),
    system: systemPrompt,
    prompt: userPrompt,
    maxTokens: 150,
    temperature: 0.9, // Add some creativity
  });

  return result.text.trim();
}

/**
 * Generate a new recipe based on liked and passed recipes using LLM
 * @param likedRecipes - Array of recipes that the user liked
 * @param passedRecipes - Array of recipes that the user passed (optional)
 * @returns Promise<Recipe> - A new recipe object generated by LLM
 */
export async function generateRecipeFromLikes({
  likedRecipes,
  passedRecipes,
}: {
  likedRecipes: Recipe[];
  passedRecipes: Recipe[];
}): Promise<Omit<Recipe, "id" | "createdAt" | "updatedAt">> {
  const githubModels = createGitHubModels();

  // Analyze liked recipes to understand preferences
  const likedIngredients = likedRecipes.flatMap(recipe => 
    recipe.ingredients.map(ing => ing.name)
  );
  const likedTags = likedRecipes.flatMap(recipe => recipe.tags || []);

  // Create system prompt for recipe generation
  const systemPrompt = `You are an expert cocktail sommelier and recipe creator. Generate a new cocktail recipe based on the user's preferences from their liked recipes.

Guidelines:
- Create a unique, well-balanced cocktail recipe
- Use ingredients and flavor profiles similar to their liked recipes
- Include name, description, ingredients with measurements, instructions, glass type, and garnish
- Make the recipe creative but realistic and mixable
- Focus on quality and balance, not just novelty
- Generate appropriate tags based on the recipe
- Ensure measurements are practical (use common bar measurements like 0.5, 0.75, 1, 1.5, 2 oz, etc.)
- Instructions should be clear and professional`;

  const userPrompt = `Based on these liked recipes, create a new cocktail recipe:

Liked Recipes:
${likedRecipes.map(recipe => `
- ${recipe.name}: ${recipe.ingredients.map(ing => `${ing.amount} ${ing.unit} ${ing.name}`).join(", ")}
  Glass: ${recipe.glass || "Not specified"}
  Tags: ${recipe.tags?.join(", ") || "None"}
`).join("")}

Disliked Recipes:
${passedRecipes.map(recipe => `
- ${recipe.name}: ${recipe.ingredients.map(ing => `${ing.amount} ${ing.unit} ${ing.name}`).join(", ")}
  Glass: ${recipe.glass || "Not specified"}
  Tags: ${recipe.tags?.join(", ") || "None"}
`).join("")}

Common ingredients in liked recipes: ${[...new Set(likedIngredients)].slice(0, 10).join(", ")}
Common tags: ${[...new Set(likedTags)].slice(0, 5).join(", ")}

Create a new recipe that would appeal to someone who liked these drinks.`;

  const result = await generateObject({
    model: githubModels(process.env.CHAT_MODEL || "openai/gpt-4.1-nano"),
    system: systemPrompt,
    prompt: userPrompt,
    schema: z.object({
      name: z.string().min(1, "Recipe name is required"),
      description: z.string(),
      ingredients: z.array(IngredientSchema).min(1, "At least one ingredient is required"),
      instructions: z.string().min(1, "Instructions are required"),
      glass: GlassTypeSchema,
      garnish: z.string(),
    }),
    maxTokens: 500,
    temperature: 0.8,
  });

  if (!result || !result.object) {
    throw new Error("Failed to generate recipe from LLM");
  }

  return {
    name: result.object.name,
    description: result.object.description,
    ingredients: result.object.ingredients as Ingredient[],
    instructions: result.object.instructions,
    glass: result.object.glass as any, // Will be validated by the schema
    garnish: result.object.garnish,
    tags: [],
  };
}
